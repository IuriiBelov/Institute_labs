#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "wayOut.h"
#include "check.h"

int checkV(elem *V, int k);
/* Функция, проверяющая, есть ли в массиве вершины, до которых требуется добраться 
   elem *V - массив вершин графа 
   int k   - размер массива вершин 
   Функция возвращает 0, если существует хоть одна такая вершина, и 1, если ни одной такой 
   вершины не существует */
int createWay(int **way, int k, int begin);
/* Функция, которая создаёт массив вершин, составляющих путь 
   int **way - указатель на массив вершин 
   int k     - размер массива 
   int begin - значение первого элемента 
   Функция возвращает 0, если массив удалосб создать, и 1, если не удалось */

void initV(elem *V, int k, int begin);
/* Функция, которая заполняет массив вершин (пройдены - не пройдены) перед началом поиска
   elem *V   - масссив вершин графа 
   int k     - размер массива 
   int begin - элемент графа, с которого начинаем движение 
   Функция ничего не возвращает */

int *wayOut(int k, int begin, elem *V)
{
  int *way;/* Массив вершин, составляющих путь */
  int current;/* Номер текущей вершины в массиве пройденных */
	int i;/* Вспомогательная переменная цикла */
  int ok;/* Переменная, равная 1, если нашлась хоть одна смежная непройденная вершина, и 0, если 
            не нашлась */
  assert(k != 0 && begin >= 0 && V != NULL);
  if (checkV(V, k))/* Если вершины, до которой нужно добраться, не существует */
    return NULL;/* То пути тоже не существует */
  way = NULL;
  if (createWay(&way, k, begin))/* Если не удалось создать массив вершин, составляющих путь */
    return NULL;/* Выходим */
  initV(V, k, begin);/* Изначальновсе вершины, кроме первой, не пройдены */
  current = 0;/* Пока в списке всего одна вершина */
  way[current] = begin;/* Та, с которой начали */
  while ((V[way[current]]).wayOut != 0)/* Пока текущая вершина не является той, до которой нужно 
                                          добраться */
  {
    ok = 0;/* Пока смежных непройденных вершин не нашли */
    /* Смотрим массив смежных вершин */
    for (i = 0; i < 4; i++)
      /* Если нашли смежную непройденную вершину */
      if (((V[way[current]]).adjacent)[i] >= 0 && (V[(((V[way[current]]).adjacent)[i])]).mark == 0)
      {
        (V[((V[way[current]]).adjacent)[i]]).mark = 1;/* Проходим её */
        current++;/* Теперь в списке пройденных вершин на одну больше */
        way[current] = ((V[way[current - 1]]).adjacent)[i];/* Эта вершина - последняя в списке */
        ok++;/* Увеличиваем счётчик смежных непройденных вершин */
        break;/* Больше смотреть не нужно. одну уже нашли */
      }
    if (ok == 0)/* Если смежных непройденных вершин нет */
    {
      way[current] = -1;
      current--;/* Возвращаемся на вершину назад */
      if (current < 0)/* Если это была вершина, из которой начали движение */
      {
        printf("There isn`t any way out\n");/* Построить путь до требуемой вершины невозможно */
        return NULL;
      }
    }
  }
  return way;
}

int checkV(elem *V, int k)
{
  int i;/* Вспомогательная переменная цикла */
  assert(V != NULL && k > 0);
  /* Пробегаемся по всем вершинам графа */
  for (i = 0; i < k; i++)
    if ((V[i]).wayOut == 0)/* Если встретили необходимую вершину */
      return 0;/* Такие вершины есть, дальше можно не смотреть, выходим */
  return 1;/* Таких вершин в графе нет */
}

int createWay(int **way, int k, int begin)
{
  int i;
  assert(way != NULL && k > 0 && begin >= 0);
  /* Выделяем памать под массив вершин пути */
  *way = calloc(k, sizeof(int));
  if (checkPointer(*way))
    return 1;/* Выделить память не удалось */
  (*way)[0] = begin;/* Первая вершина в списке - та, с которой начинаем движение */
  for (i = 1; i < k; i++)
    (*way)[i] = -1;/* Остальные вершины пока не определены */
  return 0;
}

void initV(elem *V, int k, int begin)
{
  int i;/* Вспомогательная переменная цикла */
  assert(V != NULL && k > 0 && begin >= 0);
  /* Пробегаемся по всем вершинам графа */
  for (i = 0; i < k; i++)
    if (i != begin)/* Если вершина - не первая */
      (V[i]).mark = 0;/* Она ещё не пройдена */
  (V[begin]).mark = 1;/* Первая вершина уже пройдена */
  return;
}