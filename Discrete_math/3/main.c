#include <stdio.h>
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
#include <assert.h>
#include "wayOut.h"
#include "check.h"

#define CELL 1
#define INT  2

/* Структура, содержащая информацию о клетке матрицы лабиринта */
typedef struct tag_cell
{
  int value;/* Значение 0, если клетка - "проход"; 1, если "стена" */
  int number;/* Номер клетки, если она - "проход" (по количеству "проходов") */
} cell;

int readData(cell ***M, int *m, int *n, int *i, int *j, int *k);
/* Функция, которая считывает из памяти матрицу лабиринта и координаты начального положения 
   человека. 
   cell ***M - указатель на матрицу 
   int *m    - указатель на количество строк в матрице 
   int *n    - указатель на количество столбцов в матрице 
   int *i    - указатель на строку, в которой изначально находится человек 
   int *j    - указатель на столбец, в котором изначально находится человек 
   int *k    - указатель на количество "проходов" в лабиринте 
   Функция возвращает 0, если всё прошло успешно, и 1, если нет (не открылся файл или не хватило 
   динамической памяти. */
void initGraph(cell **M, elem *V, int k, int m, int n);
/* Функция, которая инициализирует массив вершин графа, вершинами которого являются 
   "проходы" в лабиринте. Вершины графа смежны, если клетки-"проходы" соседни. 
   cell **M - матрица лабиринта 
   elem *V  - массив вершин графа 
   int k    - количество вершин в графе 
   int m    - количество строк в матрице лабиринта 
   int n    - количество столбцов в матрице лабиринта 
   Функция ничего не возвращает. */
int allocMatrix(cell ***M, int m, int n);
/* Функция, которая выделяет динамическую память под матрицу лабиринта 
   cell ***M - указатель на матрицу лабиринта 
   int m     - количество строк в матрице 
   int n     - количество столбцов в матрице 
   Функция возвращает 0, если удалось выделить память, и 1, если не удалось. */
void freeMatrix(cell **M, int m);
/* Функция, которая освобождает динамическую память, выделенную под матрицу лабиринта 
   cell **M - матрица лабиринта 
   int m    - количество строк в матрице 
   Функция ничего не возвращает. */

int main(void)
{
  cell **M = NULL;/* Матрица лабиринта */
  elem *V = NULL;/* Массив вершин графа */
  int m = 0;/* Количество строк в матрице лабиринта */
  int n = 0;/* Количество столбцов в матрице лабиринта */
  int i = 0;/* Строка, в которой изначально находится человек */
  int j = 0;/* Столбец, в котором изначально находится человек */
  int k = 0;/* Количество клеток-"проходов" в матрице лабиринта */
  int begin;/* Номер вершины графа, в которой изначально находится человек */
  int *way;/* Массив вершин, составляющих путь */
  int h;/* Вспомогательная переменная цикла */
  /* Ставим проверку на утечки памяти */
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF | _CRTDBG_CHECK_ALWAYS_DF);
  /* Считываем данные из файла */
  if (readData(&M, &m, &n, &i, &j, &k))
    return 1;
  /* выделяем память под массив вершин графа */
  V = calloc(k, sizeof(elem));
  /* Если память выделить не удалось */
  if (checkPointer(V))
    /* Освобождаем память под матрицу лабиринта */
    freeMatrix(M, m);
  /* Инициализируем массив вершин графа */
  initGraph(M, V, k, m, n);
  /* Номер вершины, где изначально находится человек */
  begin = (M[i - 1][j - 1]).number;
  way = wayOut(k, begin, V);
  if (way != NULL)
  {
    for (i = 0; i < k; i++)
      if (way[i] >= 0)
      {
        for (j = 0; j < m; j++)
          for (h = 0; h < n; h++)
            if ((M[j][h]).value == 0 && (M[j][h]).number == way[i])
              printf("(%i;%i) ", j + 1, h + 1);
      }
    printf("\n");
  }
  freeMatrix(M, m);
  free(V);
  return 0;
}

int readData(cell ***M, int *m, int *n, int *i, int *j, int *k)
{
  FILE *fp;/* Указатель на файл, из которого считываем данные */
  int a, b;/* Вспомогательные переменные цикла */
  assert(M != NULL && m != NULL && n != NULL && i != NULL && j != NULL && k != NULL);
  /* Открываем файл для чтения */
  fp = fopen("data.txt", "r");
  if (fp == NULL)
  {
    printf("ERROR: file not found\n");
    return 1;
  }
  fscanf(fp, "%i %i %i %i", m, n, i, j);/* Считали количество строк и столбцов в матрице лабиринта 
  и строку с столбец, в которых изначально располагается человек*/
  /* Выделяем память под матрицу смежностей графа */
  if (allocMatrix(M, *m, *n))
  {
    fclose(fp);
    return 1;
  }
  /* Считываем матрицу лабиринта */
  for (a = 0; a < *m; a++)
    for (b = 0; b < *n; b++)
    {
      fscanf(fp, "%i", &(((*M)[a][b]).value));
      if (((*M)[a][b]).value == 0)/* Если это клетка-"проход" */
      {
        ((*M)[a][b]).number = *k;/* То записываем номер этой клетки (нумеруем клетки с нуля) */
        (*k)++;/* И увеличиваем счётчик */
      }
    }
  fclose(fp);
  return 0;
}

void initGraph(cell **M, elem *V, int k, int m, int n)
{
  int a, b;/* Вспомогательные переменные цикла */
  int z = 0;/* Счётчик клеток-"проходов" */
  assert(M != NULL && V != NULL && k > 0 && m > 0 && n > 0);
  /* Пробегаемся по массиву вершин графа */
  for (a = 0; a < k; a++)
    /* Пробегаемся по массиву смежных вершин каждой вершины */
    for (b = 0; b < 4; b++)
      ((V[a]).adjacent)[b] = -1;/* Изначально ни у одной вершины нет смежных */
  /* Просматриваем матрицу лабиринта */
  for (a = 0; a < m; a++)
    for (b = 0; b < n; b++)
      if ((M[a][b]).value == 0)/* Если это клетка-"проход" */
      {
        (V[z]).number = z;/* Делаем эту клетку очередной вершиной графа */
        /* Если клетка-"проход" на краю лабиринта */
        if (a == 0 || a == m - 1 || b == 0 || b == n - 1)
          (V[z]).wayOut = 0;/* То это выход */
        else
          (V[z]).wayOut = 1;/* Иначе нет */
        if (a > 0)/* Смотрим верхнего соседа */
          if ((M[a - 1][b]).value == 0)/* Если верхний сосед - тоже "проход" */
            ((V[z]).adjacent)[0] = (M[a - 1][b]).number;/* Вносим его номер в массив соседей */
        if (a < m - 1)/* Смотрим нижнего соседа */
          if ((M[a + 1][b]).value == 0)/* Если нижний сосед - тоже "проход" */
            ((V[z]).adjacent)[1] = (M[a + 1][b]).number;/* Вносим его номер в массив соседей */
        if (b > 0)/* Смотрим левого соседа */
          if ((M[a][b - 1]).value == 0)/* Если левый сосед - тоже "проход" */
            ((V[z]).adjacent)[2] = (M[a][b - 1]).number;/* Вносим его номер в массив соседей */
        if (b < n - 1)/* Смотрим правого соседа */
          if ((M[a][b + 1]).value == 0)/* Если правый сосед - тоже "проход" */
            ((V[z]).adjacent)[3] = (M[a][b + 1]).number;/* Вносим его номер в массив соседей */
        z++;/* Увеличиваем счётчик вершин графа */
      }
  return;
}

int allocMatrix(cell ***M, int m, int n)
{
  int a, b;
  assert(M != NULL && m > 0 && n > 0);
  /* Выделяем память под матрицу */
  *M = calloc(m, sizeof(cell *));
  if (checkPointer(*M))
    return 1;
  /* Выделяяем память под строки матрицы */
  for (a = 0; a < m; a++)
  {
    (*M)[a] = calloc(n, sizeof(cell));
    /* Если не удалось выделить память под очередную строку */
    if (checkPointer((*M)[a]))
    {
      /* Освобождаем всё, что выделили раньше, и выходим */
      for (b = 0; b < a; b++)
        free((*M)[b]);
      free(*M);
      return 1;
    }
  }
  return 0;
}

void freeMatrix(cell **M, int m)
{
  int a;
  assert(M != NULL && m > 0);
  /* Освобождаем память под строки матрицы */
  for (a = 0; a < m; a++)
    free(M[a]);
  /* освобождаем память под матрицу */
  free(M);
  return;
}